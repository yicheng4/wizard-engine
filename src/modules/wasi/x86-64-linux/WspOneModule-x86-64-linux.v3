// Copyright 2021 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def OUT = Trace.OUT;
def X = WspOneRegistration.register(X86_64Linux_WspOneModule.new());
// Linux system call numbers
def SYS_openat = 257;
def SYS_clock_get_time = 228;
def SYS_clock_get_res = 229;
def SYS_getrandom = 318;
def SYS_mkdir = 83;
def SYS_link = 86;
def SYS_linkat = 265;

// mkdir mode is 0o777
def MKDIR_MODE = 0x1FF;
// openat flags
def O_CLOEXEC = 0x80000;
def O_PATH = 0x200000;
def O_DIRECTORY = 0x10000;

/* open-only flags */
def O_RDONLY   =     0x0000    ;      /* open for reading only */
def O_WRONLY   =     0x0001    ;      /* open for writing only */
def O_RDWR     =     0x0002    ;      /* open for reading and writing */
def O_ACCMODE  =     0x0003    ;      /* mask for above modes */
def O_SHLOCK   =     0x00000010;      /* open with shared file lock */
def O_EXLOCK   =     0x00000020;      /* open with exclusive file lock */
def O_ASYNC    =     0x00000040;      /* signal pgrp when data ready */
def O_SYNC     =     0x0080    ;      /* synch I/O file integrity */
def O_FSYNC    =     O_SYNC    ;      /* source compatibility: do not use */
def O_NOFOLLOW =     0x00000100;      /* don't follow symlinks */
def O_CREAT    =     0x00000200;      /* create if nonexistant */
def O_TRUNC    =     0x00000400;      /* truncate to zero length */
def O_EXCL     =     0x00000800;      /* error if already exists */


// wasi rights
def RIGHT_FD_DATASYNC           =  (1 << 0);
def RIGHT_FD_READ               =  (1 << 1);
def RIGHT_FD_SEEK               =  (1 << 2);
def RIGHT_FD_FDSTAT_SET_FLAGS   =  (1 << 3);
def RIGHT_FD_SYNC               =  (1 << 4);
def RIGHT_FD_TELL               =  (1 << 5);
def RIGHT_FD_WRITE              =  (1 << 6);
def RIGHT_FD_ADVISE             =  (1 << 7);
def RIGHT_FD_ALLOCATE           =  (1 << 8);
def RIGHT_PATH_CREATE_DIRECTORY =  (1 << 9);
def RIGHT_PATH_CREATE_FILE        = (1 << 10);
def RIGHT_PATH_LINK_SOURCE        = (1 << 11);
def RIGHT_PATH_LINK_TARGET        = (1 << 12);
def RIGHT_PATH_OPEN               = (1 << 13);
def RIGHT_FD_READDIR              = (1 << 14);
def RIGHT_PATH_READLINK           = (1 << 15);
def RIGHT_PATH_RENAME_SOURCE      = (1 << 16);
def RIGHT_PATH_RENAME_TARGET      = (1 << 17);
def RIGHT_PATH_FILESTAT_GET       = (1 << 18);
def RIGHT_PATH_FILESTAT_SET_SIZE  = (1 << 19);
def RIGHT_PATH_FILESTAT_SET_TIMES = (1 << 20);
def RIGHT_FD_FILESTAT_GET         = (1 << 21);
def RIGHT_FD_FILESTAT_SET_SIZE    = (1 << 22);
def RIGHT_FD_FILESTAT_SET_TIMES   = (1 << 23);
def RIGHT_PATH_SYMLINK            = (1 << 24);
def RIGHT_PATH_REMOVE_DIRECTORY   = (1 << 25);
def RIGHT_PATH_UNLINK_FILE        = (1 << 26);
def RIGHT_POLL_FD_READWRITE       = (1 << 27);
def RIGHT_SOCK_SHUTDOWN           = (1 << 28);
def RIGHT_SOCK_ACCEPT             = (1 << 29);
// IO buffers
def timespec = Array<long>.new(2);

// A special value, which tells the fd of the current working directory used in openat
def AT_FDCWD = -100;

// Platform-specific implementation of "wasi_snapshot_preview1" module.
class X86_64Linux_WspOneModule extends WspOneModule {
	def init_p(err: ErrorGen) {
		def dirs = WasiOptions.getDirs();
		// execute openat syscall for every given directory
		for (ii < dirs.length) {
			var dir = dirs[ii];
			// call openat system call
			var fd = Linux.syscall(SYS_openat, 
				(AT_FDCWD,
				 Pointer.atContents(dir),
				 LinuxConst.O_RDONLY | O_CLOEXEC | O_PATH | O_DIRECTORY
				)).0;
			if (fd < 0) {
				err.abs(0).InvalidPreopenPath(dir);
			}
			var wasi_fd = fdmap.alloc();
			fdmap.set(wasi_fd, WasiFd.new(int.view(fd), wasi_filetype.DIRECTORY, true, dir));
		}
	}

	def random_get(args: Range<Value>) -> HostResult {
		var ptr = Values.v_u(args[0]), len = Values.v_u(args[1]);
		var range = memory.range_ol_32(ptr, len);
		if (range.reason != TrapReason.NONE) return HostResult.Throw(Trap.new(range.reason, null, null));
		var t = Linux.syscall(SYS_getrandom, (Pointer.atContents(range.result), len, 0));
		if (t.0 < 0) return i(mapErrno(t.0));
		return HostResult.Value1(Values.I32_0);
	}
	def clock_res_get(args: Range<Value>) -> HostResult {
		var clock_id = mapClockId(Values.v_u(args[0]));
		if (clock_id < 0) return HostResult.Value1(Values.i_v(wasi_errno.INVAL.code));
		var ptr = Values.v_u(args[1]);
		var range = memory.range_ol_32(ptr, 8);
		if (range.reason != TrapReason.NONE) return HostResult.Throw(Trap.new(range.reason, null, null));
		var t = Linux.syscall(SYS_clock_get_res, (clock_id, Pointer.atContents(timespec)));
		if (t.0 < 0) return i(mapErrno(t.0));
		DataWriters.write_range_i64(range.result, timespec[0] * 1000000000L + timespec[1]);
		return HostResult.Value1(Values.I32_0);
	}
	def clock_time_get(args: Range<Value>) -> HostResult {
		var clock_id = mapClockId(Values.v_u(args[0]));
		if (clock_id < 0) return HostResult.Value1(Values.i_v(wasi_errno.INVAL.code));
		var lag = Values.v_l(args[1]);
		var ptr = Values.v_u(args[2]);
		var range = memory.range_ol_32(ptr, 8);
		if (range.reason != TrapReason.NONE) return HostResult.Throw(Trap.new(range.reason, null, null));
		var t = Linux.syscall(SYS_clock_get_time, (clock_id, Pointer.atContents(timespec)));
		if (t.0 < 0) return i(mapErrno(t.0));
		DataWriters.write_range_i64(range.result, timespec[0] * 1000000000L + timespec[1]);
		return HostResult.Value1(Values.I32_0);
	}
	def mapClockId(clock_id: u32) -> int {
		if (clock_id > 3) return -1;
		return int.view(clock_id); // WASI clock ids map directly onto Linux clock IDs
	}
	def mapErrno(errno: i64) -> int {
		return int.!(errno);
	}

	def path_create_directory(args : Range<Value>)->HostResult {
    		var fd = Values.v_i(args[0]), ptr = args[1];
		var wfd = fdmap.get(fd);
		if (wfd == null) return i(wasi_errno.BADF.code);
		var ptr_len = args[2];
		var buf = copyString(memory, ptr, ptr_len); 

		if (!buf.ok()) return i(wasi_errno.INVAL.code);
		var path_arr = buf.result;

                var t = WasiPathUtil.resolve_path(wfd, path_arr, 0);
                if (t.1 != wasi_errno.SUCCESS) return i(t.1.code);

                var syscall_result = Linux.syscall(SYS_mkdir, (Pointer.atContents(path_arr), MKDIR_MODE));
                if (syscall_result.0 < 0) return i(mapErrno(syscall_result.0));
                return i(wasi_errno.SUCCESS.code);

	}

	def path_link(args : Range<Value>)->HostResult { 
		var old_fd = Values.v_i(args[0]), old_flags = Values.v_i(args[1]), 
			old_path = args[2], new_fd = Values.v_i(args[3]), new_path = args[4];
		var old_wfd = fdmap.get(old_fd), new_wfd = fdmap.get(new_fd);
		if (old_wfd == null || new_wfd == null) return i(wasi_errno.BADF.code);
		var old_path_arr = copyString(memory, old_path, args[5]);
		if (!old_path_arr.ok()) return i(wasi_errno.INVAL.code);
		var new_path_arr = copyString(memory, new_path, args[6]);
		if (!new_path_arr.ok()) return i(wasi_errno.INVAL.code);
		var t = WasiPathUtil.resolve_path(old_wfd, old_path_arr.result, 0);
		if (t.1 != wasi_errno.SUCCESS) return i(t.1.code);
		var old_resolved = t.0;
		t = WasiPathUtil.resolve_path(new_wfd, new_path_arr.result, 0);
		if (t.1 != wasi_errno.SUCCESS) return i(t.1.code);
		var new_resolved = t.0;
		var syscall_result = Linux.syscall(SYS_linkat,
			(old_fd, Pointer.atContents(old_resolved), 
			new_fd, Pointer.atContents(new_resolved), old_flags));
		if (syscall_result.0 < 0) return i(mapErrno(syscall_result.0));
		return i(wasi_errno.SUCCESS.code);
	 }
	 def path_open(args : Range<Value>)->HostResult { 
		//var dirfd = Values.v_i(args[0]), dirflags = Values.v_u(args[1]), 
		//	path = args[2], o_flags = Values.v_u(args[3]), fs_rights_base = Values.v_l(args[4]), 
		//	fs_rights_inheriting = Values.v_l(args[5]), fdflags = Values.v_u(args[6]);
		//var read = 0 != (fs_rights_base & (RIGHT_FD_READ |
                //                 RIGHT_FD_READDIR));
		//var write = 0 != (fs_rights_base & (RIGHT_FD_DATASYNC |
                //                  RIGHT_FD_WRITE |
                //                  RIGHT_FD_ALLOCATE |
                //                  RIGHT_FD_FILESTAT_SET_SIZE));

		//var flags : u32 = if (write, if (read, O_RDWR, O_WRONLY), O_RDONLY);

		return i(wasi_errno.SUCCESS.code);
	//	if ((o_flags & UVWASI_O_CREAT) != 0) {
	//flags |= UV_FS_O_CREAT;
	//needed_base |= UVWASI_RIGHT_PATH_CREATE_FILE;
	//}
	//if ((o_flags & UVWASI_O_DIRECTORY) != 0)
	//flags |= UV_FS_O_DIRECTORY;
	//if ((o_flags & UVWASI_O_EXCL) != 0)
	//flags |= UV_FS_O_EXCL;
	//if ((o_flags & UVWASI_O_TRUNC) != 0) {
	//flags |= UV_FS_O_TRUNC;
	//needed_base |= UVWASI_RIGHT_PATH_FILESTAT_SET_SIZE;
	//}

	//if ((fs_flags & UVWASI_FDFLAG_APPEND) != 0)
	//flags |= UV_FS_O_APPEND;
	//if ((fs_flags & UVWASI_FDFLAG_DSYNC) != 0) {
	//flags |= UV_FS_O_DSYNC;
	//needed_inheriting |= UVWASI_RIGHT_FD_DATASYNC;
	//}
	//if ((fs_flags & UVWASI_FDFLAG_NONBLOCK) != 0)
	//flags |= UV_FS_O_NONBLOCK;
	//if ((fs_flags & UVWASI_FDFLAG_RSYNC) != 0) {
	//#ifdef O_RSYNC
	//flags |= O_RSYNC; /* libuv has no UV_FS_O_RSYNC. */
	//#else
	//flags |= UV_FS_O_SYNC;
	//#endif
	//needed_inheriting |= UVWASI_RIGHT_FD_SYNC;
	//}
	//if ((fs_flags & UVWASI_FDFLAG_SYNC) != 0) {
	//flags |= UV_FS_O_SYNC;
	//needed_inheriting |= UVWASI_RIGHT_FD_SYNC;
	//}
	//if (write && (flags & (UV_FS_O_APPEND | UV_FS_O_TRUNC)) == 0)
	//needed_inheriting |= UVWASI_RIGHT_FD_SEEK;

		}
	// def path_readlink(args : Range<Value>)->HostResult { return UNIMPLEMENTED; }
	// def path_remove_directory(args : Range<Value>)->HostResult { return UNIMPLEMENTED; }



}
